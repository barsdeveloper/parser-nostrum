class t{static makeSuccess(t,e){return{status:!0,value:e,position:t}}static makeFailure(t,e=null){return{status:!1,value:e,position:t}}static makeContext(t=null,e=""){return{parsernostrum:t,input:e,visited:new Map}}}class e{static indentation="    ";static highlight="Last valid parser";Self;static appendBeforeHighlight(t,r){return t.endsWith(e.highlight)?t=t.replace(/(?=(?:\n|^).+$)/,r):t+=r,t}static lastRowLength(t,e=0){const r=t.match(/(?:\n|(^))([^\n]*)$/),s=void 0!==r[1]?e:0;return r[2].length+s}constructor(){this.Self=this.constructor}unwrap(){return[]}wrap(...t){return null}parse(t,e){return null}toString(e=t.makeContext(null,""),r=0,s=null){return e.visited.has(this)?"<...>":(e.visited.set(this,null),this.doToString(e,r,s))}doToString(t,e,r){return`${this.constructor.name} does not implement toString()`}}class r extends e{static successParserInstance;#t;get value(){return this.#t}constructor(t){super(),this.#t=t}parse(e,r){const s=r+this.#t.length,n=e.input.substring(r,s);return this.#t===n?t.makeSuccess(s,this.#t):t.makeFailure(r)}doToString(t,r,s){const n=this.value.replaceAll("\n","\\n");let i=this.value.match(/^[a-zA-Z]$/)?n:`"${n.replaceAll('"','\\"')}"`;return s===this&&(i+="\n"+e.indentation.repeat(r)+"^".repeat(i.length)+" "+e.highlight),i}}class s extends r{static instance=new s;static{r.successParserInstance=this.instance}constructor(){super("")}doToString(t,r,s){return"<SUCCESS>"+(s===this?`\n${e.indentation.repeat(r)}^^^^^^^^^ ${e.highlight}`:"")}}class n extends e{static highlightRegexp=new RegExp(String.raw`(?<=[^\S\n]*\| .*\n)^(?=[^\S\n]*\^+ ${e.highlight}(?:\n|$))`,"m");#e;get parsers(){return this.#e}constructor(...t){super(),this.#e=t}unwrap(){return[...this.#e]}wrap(...t){return new this.Self(...t)}parse(e,r){let s=t.makeFailure(r);for(let t=0;t<this.#e.length;++t){const n=this.#e[t].parse(e,r);if(n.status)return n;n.position>s.position&&n.value&&(s=n)}return s}doToString(t,i,a){const h=e.indentation.repeat(i),p=e.indentation.repeat(i+1);if(2===this.#e.length&&this.#e[1]instanceof s){let e=this.#e[0].toString(t,i,a);return this.#e[0]instanceof r||t.visited.has(this.#e[0])||(e="<"+e+">"),e+="?",e}let u=this.#e.map((e=>e.toString(t,i+1,a))).join("\n"+p+"| ");return a&&(u=u.replace(n.highlightRegexp,"  ")),"ALT<\n"+(a===this?`${h}^^^ ${e.highlight}\n`:"")+p+u+"\n"+h+">"}}class i extends e{#r;get parser(){return this.#r}#s;constructor(t,e){super(),this.#r=t,this.#s=e}unwrap(){return[this.#r]}wrap(...t){return new i(t[0],this.#s)}parse(t,e){const r=this.#r.parse(t,e);if(!r.status)return r;const s=this.#s(r.value,t.input,r.position).getParser().parse(t,r.position);return s||r}doToString(t,r,s){const n="chained<f()>";let i=this.#r.toString(t,r,s);return s===this?i+=" => "+n+"\n"+e.indentation.repeat(r)+" ".repeat(i.match(/(?:\n|^)([^\n]+)$/)?.[1].length+4)+"^".repeat(12)+" "+e.highlight:i=e.appendBeforeHighlight(i," => "+n),i}}class a extends e{static instance=new a;parse(e,r){return t.makeFailure(r)}doToString(t,r,s){return"<FAILURE>"+(s===this?`\n${e.indentation.repeat(r)}^^^^^^^^^ ${e.highlight}`:"")}}class h extends e{#r;#n;constructor(t){super(),this.#r=t}resolve(){return this.#n||(this.#n=this.#r().getParser()),this.#n}unwrap(){return[this.resolve()]}wrap(...t){const e=this.#r().constructor;return new h((()=>new e(t[0])))}parse(t,e){return this.resolve(),this.#n.parse(t,e)}doToString(t,e,r){return this.resolve().toString(t,e,r===this?this.#n:r)}}class p extends e{#r;get parser(){return this.#r}#i;get type(){return this.#i}static Type={NEGATIVE_AHEAD:"?!",NEGATIVE_BEHIND:"?<!",POSITIVE_AHEAD:"?=",POSITIVE_BEHIND:"?<="};constructor(t,e){super(),this.#r=t,this.#i=e}unwrap(){return[this.#r]}wrap(...t){return new p(t[0],this.#i)}parse(e,r){return this.#r.parse(e,r).status==(this.#i===p.Type.POSITIVE_AHEAD)?t.makeSuccess(r,""):t.makeFailure(r)}doToString(t,r,s){let n="("+this.#i+this.#r.toString(t,r,s)+")";return s===this&&(n=n.replace(/(\n)|$/,"\n"+e.indentation.repeat(r)+"^".repeat(this.#i.length+1)+" "+e.highlight+"$1")),n}}class u extends e{#r;get parser(){return this.#r}#a;get mapper(){return this.#a}constructor(t,e){super(),this.#r=t,this.#a=e}unwrap(){return[this.#r]}wrap(...t){return new u(t[0],this.#a)}parse(t,e){const r=this.#r.parse(t,e);return r.status&&(r.value=this.#a(r.value)),r}doToString(t,r,s){let n=this.#a.toString();(n.length>60||n.includes("\n"))&&(n="(...) => { ... }");let i=this.#r.toString(t,r,s===this?this.#r:s);return i=e.appendBeforeHighlight(i,` -> map<${n}>`),i}}class o extends e{#h;get regexp(){return this.#h}#p;#u;constructor(t,e){super(),t instanceof RegExp?(this.#h=t,this.#p=new RegExp(`^(?:${t.source})`,t.flags)):t instanceof o&&(this.#h=t.#h,this.#p=t.#p),this.#u=e}parse(e,r){const s=this.#p.exec(e.input.substring(r));return s?t.makeSuccess(r+s[0].length,this.#u>=0?s[this.#u]:s):t.makeFailure(r)}doToString(t,r,s){let n="/"+this.#h.source+"/";return s===this&&(n+="\n"+e.indentation.repeat(r)+"^".repeat(n.length)+" "+e.highlight),n}}class c extends e{#e;get parsers(){return this.#e}constructor(...t){super(),this.#e=t}unwrap(){return[...this.#e]}wrap(...t){return new c(...t)}parse(e,r){const s=new Array(this.#e.length),n=t.makeSuccess(r,s);for(let r=0;r<this.#e.length;++r){const s=this.#e[r].parse(e,n.position);if(!s.status)return t.makeFailure(n.position,r>0?this.#e[r-1]:null);n.value[r]=s.value,n.position=s.position}return n}doToString(t,r,s){const n=e.indentation.repeat(r),i=e.indentation.repeat(r+1);return"SEQ<\n"+(s===this?`${n}^^^ ${e.highlight}\n`:"")+this.#e.map((e=>i+e.toString(t,r+1,s))).join("\n")+"\n"+n+">"}}class l extends e{#r;get parser(){return this.#r}#o;get min(){return this.#o}#c;get max(){return this.#c}constructor(t,e=0,r=Number.POSITIVE_INFINITY){if(super(),e>r)throw new Error("Min is greater than max");this.#r=t,this.#o=e,this.#c=r}unwrap(){return[this.#r]}wrap(...t){return new l(t[0],this.#o,this.#c)}parse(e,r){const s=t.makeSuccess(r,[]);for(let n=0;n<this.#c;++n){const i=this.#r.parse(e,s.position);if(!i.status)return n>=this.#o?s:t.makeFailure(r);s.value.push(i.value),s.position=i.position}return s}doToString(t,r,s){let n=this.parser.toString(t,r,s);const i=0===this.#o&&1===this.#c?"?":0===this.#o&&this.#c===Number.POSITIVE_INFINITY?"*":1===this.#o&&this.#c===Number.POSITIVE_INFINITY?"+":"{"+this.#o+(this.#o!==this.#c?","+this.#c:"")+"}";return s===this?n+=i+"\n"+" ".repeat(e.lastRowLength(n,e.indentation.length*r))+"^".repeat(i.length)+" "+e.highlight:n=e.appendBeforeHighlight(n,i),n}}class g{#r;Self;static#l=([t,e])=>t;static#g=([t,e])=>e;static#m=([t,e])=>[t,...e];static#d=t=>t instanceof Array?t.join(""):t;static#w=t=>String.raw`[^${t}\\]*(?:\\.[^${t}\\]*)*`;static#S=/[-\+]?(?:\d*\.)?\d+/;static number=this.reg(new RegExp(this.#S.source+String.raw`(?!\.)`)).map(Number);static numberInteger=this.reg(/[\-\+]?\d+(?!\.\d)/).map(Number);static numberBigInteger=this.reg(this.numberInteger.getParser().parser.regexp).map(BigInt);static numberNatural=this.reg(/\d+/).map(Number);static numberExponential=this.reg(new RegExp(this.#S.source+String.raw`(?:[eE][\+\-]?\d+)?(?!\.)`)).map(Number);static numberUnit=this.reg(/\+?(?:0(?:\.\d+)?|1(?:\.0+)?)(?![\.\d])/).map(Number);static numberByte=this.reg(/0*(?:25[0-5]|2[0-4]\d|1?\d?\d)(?!\d|\.)/).map(Number);static whitespace=this.reg(/\s+/);static whitespaceOpt=this.reg(/\s*/);static whitespaceInline=this.reg(/[^\S\n]+/);static whitespaceInlineOpt=this.reg(/[^\S\n]+/);static whitespaceMultiline=this.reg(/\s*?\n\s*/);static doubleQuotedString=this.regArray(new RegExp(`"(${this.#w('"')})"`)).map(this.#g);static singleQuotedString=this.regArray(new RegExp(`'(${this.#w("'")})'`)).map(this.#g);static backtickQuotedString=this.regArray(new RegExp(`\`(${this.#w("`")})\``)).map(this.#g);constructor(t,e=!1){this.Self=this.constructor,this.#r=t}getParser(){return this.#r}run(e){const r=this.#r.parse(t.makeContext(this,e),0);return r.status&&r.position===e.length?r:t.makeFailure(r.position)}parse(t){const e=this.run(t);if(!e.status)throw new Error(`Could not parse "${t.length>20?t.substring(0,17)+"...":t}"`);return e.value}static str(t){return new this(new r(t))}static reg(t,e=0){return new this(new o(t,e))}static regArray(t){return new this(new o(t,-1))}static success(){return new this(s.instance)}static failure(){return new this(a.instance)}static seq(...t){return new this(new c(...t.map((t=>t.getParser()))))}static alt(...t){return new this(new n(...t.map((t=>t.getParser()))))}static lookahead(t){return new this(new p(t.getParser(),p.Type.POSITIVE_AHEAD))}static lazy(t){return new this(new h(t))}times(t,e=t){return new this.Self(new l(this.#r,t,e))}many(){return this.times(0,Number.POSITIVE_INFINITY)}atLeast(t){return this.times(t,Number.POSITIVE_INFINITY)}atMost(t){return this.times(0,t)}opt(){return this.Self.alt(this,this.Self.success())}sepBy(t,e=!1){return this.Self.seq(this,this.Self.seq(t,this).map(g.#g).many()).map(g.#m)}skipSpace(){return this.Self.seq(this,this.Self.whitespaceOpt).map(g.#l)}map(t){return new this.Self(new u(this.#r,t))}chain(t){return new this.Self(new i(this.#r,t))}assert(t){return this.chain(((e,r,s)=>t(e,r,s)?this.Self.success().map((()=>e)):this.Self.failure()))}join(t=""){return this.map(g.#d)}toString(r=0,s=!1,n=null){return(s?"\n"+e.indentation.repeat(r):"")+this.#r.toString(t.makeContext(this,""),r,n?.getParser())}}export{g as default};
