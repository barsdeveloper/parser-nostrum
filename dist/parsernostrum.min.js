class e{static makeSuccess(e,t,r=null,s=0){return{status:!0,value:t,position:e,bestParser:r,bestPosition:s}}static makeFailure(e=0,t=null,r=0){return{status:!1,value:null,position:e,bestParser:t,bestPosition:r}}static makeContext(e=null,t=""){return{parsernostrum:e,input:t,highlighted:null}}static makePathNode(e,t=0,r=null){return{parent:r,parser:e,index:t}}}class t{static indentation="    ";static highlight="Last valid parser";Self;static appendBeforeHighlight(e,r){return e.endsWith(t.highlight)?e=e.replace(/(?=(?:\n|^).+$)/,r):e+=r,e}static lastRowLength(e,t=0){const r=e.match(/(?:\n|(^))([^\n]*)$/),s=void 0!==r[1]?t:0;return r[2].length+s}isHighlighted(e,r){if(e.highlighted instanceof t)return e.highlighted===this;if(!e.highlighted||!r)return!1;let s,i,n,a;e:for(s=r,n=e.highlighted;s&&n;i=s,s=s.parent,a=n,n=n.parent)if(s.parser!==n.parser||s.index!==n.index){if(!i||!a)return!1;let e,t;for(e=s,t=n;e||t;e=e?.parent,t=t?.parent){const r=e?.parser===i.parser,h=t?.parser===a.parser;if(r||h){r&&(i=e),h&&(a=t),s=i,n=a;continue e}}return!1}return!0}isVisited(e){if(!e)return!1;for(e=e.parent;null!=e;e=e.parent)if(e.parser===this)return!0;return!1}parse(e,t,r){return null}toString(t=e.makeContext(null,""),r=0,s=null){if(this.isVisited(s))return"<...>";return this.doToString(t,r,s)}doToString(e,t,r){return`${this.constructor.name} does not implement toString()`}}class r extends t{#e;get value(){return this.#e}constructor(e){super(),this.#e=e}parse(t,r,s){const i=r+this.#e.length,n=t.input.substring(r,i);return this.#e===n?e.makeSuccess(i,this.#e,s,i):e.makeFailure()}doToString(e,r,s){const i=this.value.replaceAll("\n","\\n");let n=this.value.match(/^[a-zA-Z]$/)?i:`"${i.replaceAll('"','\\"')}"`;return this.isHighlighted(e,s)&&(n+="\n"+t.indentation.repeat(r)+"^".repeat(n.length)+" "+t.highlight),n}}class s extends t{static instance=new s;parse(t,r,s){return e.makeSuccess(r,"",s,0)}doToString(e,r,s){return"<SUCCESS>"+(this.isHighlighted(e,s)?`\n${t.indentation.repeat(r)}^^^^^^^^^ ${t.highlight}`:"")}}class i extends t{static highlightRegexp=new RegExp(String.raw`(?<=[^\S\n]*\| .*\n)^(?=[^\S\n]*\^+ ${t.highlight}(?:\n|$))`,"m");#t;get parsers(){return this.#t}constructor(...e){super(),this.#t=e}parse(t,r,s){const i=e.makeSuccess(0,"");for(let e=0;e<this.#t.length;++e){const n=this.#t[e].parse(t,r,{parent:s,parser:this.#t[e],index:e});if(n.bestPosition>i.bestPosition&&(i.bestParser=n.bestParser,i.bestPosition=n.bestPosition),n.status)return i.value=n.value,i.position=n.position,i}return i.status=!1,i.value=null,i}doToString(e,n,a){const h=t.indentation.repeat(n),o=t.indentation.repeat(n+1);if(2===this.#t.length&&this.#t[1]instanceof s){let t=this.#t[0].toString(e,n,{parent:a,parser:this.#t[0],index:0});return this.#t[0]instanceof r||(t="<"+t+">"),t+="?",t}let p=this.#t.map(((t,r)=>t.toString(e,n+1,{parent:a,parser:t,index:r}))).join("\n"+o+"| ");return e.highlighted&&(p=p.replace(i.highlightRegexp,"  ")),"ALT<\n"+(this.isHighlighted(e,a)?`${h}^^^ ${t.highlight}\n`:"")+o+p+"\n"+h+">"}}class n extends t{#r;get parser(){return this.#r}#s;constructor(e,t){super(),this.#r=e,this.#s=t}parse(e,t,r){const s=this.#r.parse(e,t,{parent:r,parser:this.#r,index:0});if(!s.status)return s;const i=this.#s(s.value,e.input,s.position).getParser().parse(e,s.position);return s.bestPosition>i.bestPosition&&(i.bestParser=s.bestParser,i.bestPosition=s.bestPosition),i}doToString(e,r,s){const i="chained<f()>";let n=this.#r.toString(e,r,{parent:s,parser:this.#r,index:0});return this.isHighlighted(e,s)?n+=" => "+i+"\n"+t.indentation.repeat(r)+" ".repeat(n.match(/(?:\n|^)([^\n]+)$/)?.[1].length+4)+"^".repeat(12)+" "+t.highlight:n=t.appendBeforeHighlight(n," => "+i),n}}class a extends t{static instance=new a;parse(t,r,s){return e.makeFailure()}doToString(e,r,s){return"<FAILURE>"+(this.isHighlighted(e,s)?`\n${t.indentation.repeat(r)}^^^^^^^^^ ${t.highlight}`:"")}}class h extends t{#r;#i;constructor(e){super(),this.#r=e}resolve(){return this.#i||(this.#i=this.#r().getParser()),this.#i}parse(e,t,r){return this.resolve(),this.#i.parse(e,t,{parent:r,parser:this.#i,index:0})}doToString(e,r,s){const i={parent:s,parser:this.#i,index:0};return this.isHighlighted(e,s)&&(e.highlighted=e.highlighted instanceof t?this.#i:i),this.resolve().toString(e,r,i)}}class o extends t{#r;get parser(){return this.#r}#n;get type(){return this.#n}static Type={NEGATIVE_AHEAD:"?!",NEGATIVE_BEHIND:"?<!",POSITIVE_AHEAD:"?=",POSITIVE_BEHIND:"?<="};constructor(e,t){super(),this.#r=e,this.#n=t}parse(t,r,s){let i=this.#r.parse(t,r,{parent:s,parser:this.#r,index:0});return i=i.status==(this.#n===o.Type.POSITIVE_AHEAD)?e.makeSuccess(r,"",s,r):e.makeFailure(),i}doToString(e,r,s){let i="("+this.#n+this.#r.toString(e,r,{parent:s,parser:this.#r,index:0})+")";return this.isHighlighted(e,s)&&(i=i.replace(/(\n)|$/,"\n"+t.indentation.repeat(r)+"^".repeat(this.#n.length+1)+" "+t.highlight+"$1")),i}}class p extends t{#a;get regexp(){return this.#a}#h;#o;static#p=e=>String.raw`[^${e}\\]*(?:\\.[^${e}\\]*)*`;static#u=/[-\+]?(?:\d*\.)?\d+/;static common={number:new RegExp(this.#u.source+String.raw`(?!\.)`),numberInteger:/[\-\+]?\d+(?!\.\d)/,numberNatural:/\d+/,numberExponential:new RegExp(this.#u.source+String.raw`(?:[eE][\+\-]?\d+)?(?!\.)`),numberUnit:/\+?(?:0(?:\.\d+)?|1(?:\.0+)?)(?![\.\d])/,numberByte:/0*(?:25[0-5]|2[0-4]\d|1?\d?\d)(?!\d|\.)/,whitespace:/\s+/,whitespaceOpt:/\s*/,whitespaceInline:/[^\S\n]+/,whitespaceInlineOpt:/[^\S\n]*/,whitespaceMultiline:/\s*?\n\s*/,doubleQuotedString:new RegExp(`"(${this.#p('"')})"`),singleQuotedString:new RegExp(`'(${this.#p("'")})'`),backtickQuotedString:new RegExp("`("+this.#p("`")+")`")};constructor(e,t){super(),this.#a=e,this.#h=new RegExp(`^(?:${e.source})`,e.flags),this.#o=t}parse(t,r,s){const i=this.#h.exec(t.input.substring(r));i&&(r+=i[0].length);return i?e.makeSuccess(r,this.#o(i),s,r):e.makeFailure()}doToString(e,r,s){let i="/"+this.#a.source+"/";const n=Object.entries(p.common).find((([e,t])=>t.source===this.#a.source))?.[0];return n&&(i="P."+n),this.isHighlighted(e,s)&&(i+="\n"+t.indentation.repeat(r)+"^".repeat(i.length)+" "+t.highlight),i}}class u extends t{#r;get parser(){return this.#r}#l;get mapper(){return this.#l}constructor(e,t){super(),this.#r=e,this.#l=t}parse(e,t,r){const s=this.#r.parse(e,t,{parent:r,parser:this.#r,index:0});return s.status&&(s.value=this.#l(s.value)),s}doToString(e,r,s){const i={parent:s,parser:this.#r,index:0};this.isHighlighted(e,s)&&(e.highlighted=e.highlighted instanceof t?this.#r:i);let n=this.#r.toString(e,r,i);if(this.#r instanceof p&&Object.values(p.common).includes(this.#r.regexp))return this.#r.regexp===p.common.numberInteger&&this.#l===BigInt?"P.numberBigInteger":n;let a=this.#l.toString();return(a.length>60||a.includes("\n"))&&(a="(...) => { ... }"),a=` -> map<${a}>`,n=t.appendBeforeHighlight(n,a),n}}class l extends p{static#l=e=>e;constructor(e){super(e,l.#l)}}class c extends p{constructor(e,t=0){super(e,(e=>e[t]))}}class g extends t{#t;get parsers(){return this.#t}constructor(...e){super(),this.#t=e}parse(t,r,s){const i=new Array(this.#t.length),n=e.makeSuccess(r,i);for(let e=0;e<this.#t.length;++e){const r=this.#t[e].parse(t,n.position,{parent:s,parser:this.#t[e],index:e});if(r.bestPosition>n.bestPosition&&(n.bestParser=r.bestParser,n.bestPosition=r.bestPosition),!r.status){n.status=!1,n.value=null;break}n.value[e]=r.value,n.position=r.position}return n}doToString(e,r,s){const i=t.indentation.repeat(r),n=t.indentation.repeat(r+1);return"SEQ<\n"+(this.isHighlighted(e,s)?`${i}^^^ ${t.highlight}\n`:"")+this.#t.map(((t,i)=>n+t.toString(e,r+1,{parent:s,parser:t,index:i}))).join("\n")+"\n"+i+">"}}class m extends t{#r;get parser(){return this.#r}#c;get min(){return this.#c}#g;get max(){return this.#g}constructor(e,t=0,r=Number.POSITIVE_INFINITY){if(super(),t>r)throw new Error("Min is greater than max");this.#r=e,this.#c=t,this.#g=r}parse(t,r,s){const i=e.makeSuccess(r,[],s);for(let e=0;e<this.#g;++e){const r=this.#r.parse(t,i.position,{parent:s,parser:this.#r,index:0});if(r.bestPosition>i.bestPosition&&(i.bestParser=r.bestParser,i.bestPosition=r.bestPosition),!r.status){e<this.#c&&(i.status=!1,i.value=null);break}i.value.push(r.value),i.position=r.position}return i}doToString(e,r,s){let i=this.parser.toString(e,r,{parent:s,parser:this.parser,index:0});const n=0===this.#c&&1===this.#g?"?":0===this.#c&&this.#g===Number.POSITIVE_INFINITY?"*":1===this.#c&&this.#g===Number.POSITIVE_INFINITY?"+":"{"+this.#c+(this.#c!==this.#g?","+this.#g:"")+"}";return this.isHighlighted(e,s)?i+=n+"\n"+" ".repeat(t.lastRowLength(i,t.indentation.length*r))+"^".repeat(n.length)+" "+t.highlight:i=t.appendBeforeHighlight(i,n),i}}class d{#r;Self;static lineColumnFromOffset(e,t){const r=e.substring(0,t).split("\n");return{line:r.length,column:r[r.length-1].length+1}}static#m=([e,t])=>e;static#d=([e,t])=>t;static#b=([e,t])=>[e,...t];static#x=e=>e instanceof Array?e.join(""):e;static#p=e=>String.raw`[^${e}\\]*(?:\\.[^${e}\\]*)*`;static number=this.reg(p.common.number).map(Number);static numberInteger=this.reg(p.common.numberInteger).map(Number);static numberBigInteger=this.reg(this.numberInteger.getParser().parser.regexp).map(BigInt);static numberNatural=this.reg(p.common.numberNatural).map(Number);static numberExponential=this.reg(p.common.numberExponential).map(Number);static numberUnit=this.reg(p.common.numberUnit).map(Number);static numberByte=this.reg(p.common.numberByte).map(Number);static whitespace=this.reg(p.common.whitespace);static whitespaceOpt=this.reg(p.common.whitespaceOpt);static whitespaceInline=this.reg(p.common.whitespaceInline);static whitespaceInlineOpt=this.reg(p.common.whitespaceInlineOpt);static whitespaceMultiline=this.reg(p.common.whitespaceMultiline);static doubleQuotedString=this.reg(p.common.doubleQuotedString,1);static singleQuotedString=this.reg(p.common.singleQuotedString,1);static backtickQuotedString=this.reg(p.common.backtickQuotedString,1);constructor(e,t=!1){this.#r=e}getParser(){return this.#r}run(t){const r=this.#r.parse(e.makeContext(this,t),0,e.makePathNode(this.#r));return r.position!==t.length&&(r.status=!1),r}parse(e){const t=this.run(e);if(!t.status){const r=60,s=[Math.ceil(r/2),Math.floor(r/2)],i=d.lineColumnFromOffset(e,t.bestPosition);let n=t.bestPosition;const a=e.replaceAll(/^(\s)+|\s{6,}|\s*?\n\s*/g,((e,r,s)=>{let i=r?"...":" ... ";return s<=t.bestPosition&&(t.bestPosition<s+e.length?n-=t.bestPosition-s:n-=e.length-i.length),i})),h=a.substring(0,r).trimEnd(),o=Math.min(e.substring(t.bestPosition-s[0]).match(/^\s*/)[0].length,s[0]-1);let p=Math.min(n,s[0]-o);s[0]=Math.max(0,n-s[0])+o,s[1]=Math.min(e.length,s[0]+r);let u=a.substring(...s);throw s[0]>0&&(u="..."+u,p+=3),s[1]<a.length-1&&(u+="..."),new Error(`Could not parse: ${h}\n\nInput: ${u}\n       `+" ".repeat(p)+`^ From here (line: ${i.line}, column: ${i.column}, offset: ${t.bestPosition})${t.bestPosition===e.length?", end of string":""}\n\n`+(t.bestParser?"Last valid parser matched:":"No parser matched:")+this.toString(1,!0,t.bestParser)+"\n")}return t.value}static str(e){return new this(new r(e))}static reg(e,t=0){return new this(new c(e,t))}static regArray(e){return new this(new l(e))}static success(){return new this(s.instance)}static failure(){return new this(a.instance)}static seq(...e){return new this(new g(...e.map((e=>e.getParser()))))}static alt(...e){return new this(new i(...e.map((e=>e.getParser()))))}static lookahead(e){return new this(new o(e.getParser(),o.Type.POSITIVE_AHEAD))}static lazy(e){return new this(new h(e))}times(e,t=e){return new d(new m(this.#r,e,t))}many(){return this.times(0,Number.POSITIVE_INFINITY)}atLeast(e){return this.times(e,Number.POSITIVE_INFINITY)}atMost(e){return this.times(0,e)}opt(){return d.alt(this,d.success())}sepBy(e,t=!1){return d.seq(this,d.seq(e,this).map(d.#d).many()).map(d.#b)}skipSpace(){return d.seq(this,d.whitespaceOpt).map(d.#m)}map(e){return new d(new u(this.#r,e))}chain(e){return new d(new n(this.#r,e))}assert(e){return this.chain(((t,r,s)=>e(t,r,s)?d.success().map((()=>t)):d.failure()))}join(e=""){return this.map(d.#x)}toString(r=0,s=!1,i=null){i instanceof d&&(i=i.getParser());const n=e.makeContext(this,"");return n.highlighted=i,(s?"\n"+t.indentation.repeat(r):"")+this.#r.toString(n,r,e.makePathNode(this.#r))}}export{d as default};
