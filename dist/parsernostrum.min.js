class e{static makeSuccess(e,t,r=null,s=0){return{status:!0,value:t,position:e,bestParser:r,bestPosition:s}}static makeFailure(e=0,t=null,r=0){return{status:!1,value:null,position:e,bestParser:t,bestPosition:r}}static makeContext(e=null,t=""){return{parsernostrum:e,input:t,highlighted:null}}static makePathNode(e,t=0,r=null){return{parent:r,parser:e,index:t}}}class t{static indentation="    ";static highlight="Last valid parser";Self;static appendBeforeHighlight(e,r){return e.endsWith(t.highlight)?e=e.replace(/(?=(?:\n|^).+$)/,r):e+=r,e}static lastRowLength(e,t=0){const r=e.match(/(?:\n|(^))([^\n]*)$/),s=void 0!==r[1]?t:0;return r[2].length+s}isHighlighted(e,r){if(e.highlighted instanceof t)return e.highlighted===this;if(!e.highlighted||!r)return!1;let s,i,n,a;e:for(s=r,n=e.highlighted;s&&n;i=s,s=s.parent,a=n,n=n.parent)if(s.parser!==n.parser||s.index!==n.index){if(!i||!a)return!1;let e,t;for(e=s,t=n;e||t;e=e?.parent,t=t?.parent){const r=e?.parser===i.parser,h=t?.parser===a.parser;if(r||h){r&&(i=e),h&&(a=t),s=i,n=a;continue e}}return!1}return!0}isVisited(e){if(!e)return!1;for(e=e.parent;null!=e;e=e.parent)if(e.parser===this)return!0;return!1}parse(e,t,r){return null}toString(t=e.makeContext(null,""),r=0,s=null){if(this.isVisited(s))return"<...>";return this.doToString(t,r,s)}doToString(e,t,r){return`${this.constructor.name} does not implement toString()`}}class r extends t{static successParserInstance;#e;get value(){return this.#e}constructor(e){super(),this.#e=e}parse(t,r,s){const i=r+this.#e.length,n=t.input.substring(r,i);return this.#e===n?e.makeSuccess(i,this.#e,s,i):e.makeFailure()}doToString(e,r,s){const i=this.value.replaceAll("\n","\\n");let n=this.value.match(/^[a-zA-Z]$/)?i:`"${i.replaceAll('"','\\"')}"`;return this.isHighlighted(e,s)&&(n+="\n"+t.indentation.repeat(r)+"^".repeat(n.length)+" "+t.highlight),n}}class s extends r{static instance=new s;static{r.successParserInstance=this.instance}constructor(){super("")}doToString(e,r,s){return"<SUCCESS>"+(this.isHighlighted(e,s)?`\n${t.indentation.repeat(r)}^^^^^^^^^ ${t.highlight}`:"")}}class i extends t{static highlightRegexp=new RegExp(String.raw`(?<=[^\S\n]*\| .*\n)^(?=[^\S\n]*\^+ ${t.highlight}(?:\n|$))`,"m");#t;get parsers(){return this.#t}constructor(...e){super(),this.#t=e}parse(t,r,s){const i=e.makeSuccess(0,"");for(let e=0;e<this.#t.length;++e){const n=this.#t[e].parse(t,r,{parent:s,parser:this.#t[e],index:e});if(n.bestPosition>i.bestPosition&&(i.bestParser=n.bestParser,i.bestPosition=n.bestPosition),n.status)return i.value=n.value,i.position=n.position,i}return i.status=!1,i.value=null,i}doToString(e,n,a){const h=t.indentation.repeat(n),p=t.indentation.repeat(n+1);if(2===this.#t.length&&this.#t[1]instanceof s){let t=this.#t[0].toString(e,n,{parent:a,parser:this.#t[0],index:0});return this.#t[0]instanceof r||(t="<"+t+">"),t+="?",t}let o=this.#t.map(((t,r)=>t.toString(e,n+1,{parent:a,parser:t,index:r}))).join("\n"+p+"| ");return e.highlighted&&(o=o.replace(i.highlightRegexp,"  ")),"ALT<\n"+(this.isHighlighted(e,a)?`${h}^^^ ${t.highlight}\n`:"")+p+o+"\n"+h+">"}}class n extends t{#r;get parser(){return this.#r}#s;constructor(e,t){super(),this.#r=e,this.#s=t}parse(e,t,r){const s=this.#r.parse(e,t,{parent:r,parser:this.#r,index:0});if(!s.status)return s;const i=this.#s(s.value,e.input,s.position).getParser().parse(e,s.position);return i||s}doToString(e,r,s){const i="chained<f()>";let n=this.#r.toString(e,r,{parent:s,parser:this.#r,index:0});return this.isHighlighted(e,s)?n+=" => "+i+"\n"+t.indentation.repeat(r)+" ".repeat(n.match(/(?:\n|^)([^\n]+)$/)?.[1].length+4)+"^".repeat(12)+" "+t.highlight:n=t.appendBeforeHighlight(n," => "+i),n}}class a extends t{static instance=new a;parse(t,r,s){return e.makeFailure()}doToString(e,r,s){return"<FAILURE>"+(this.isHighlighted(e,s)?`\n${t.indentation.repeat(r)}^^^^^^^^^ ${t.highlight}`:"")}}class h extends t{#r;#i;constructor(e){super(),this.#r=e}resolve(){return this.#i||(this.#i=this.#r().getParser()),this.#i}parse(e,t,r){return this.resolve(),this.#i.parse(e,t,{parent:r,parser:this.#i,index:0})}doToString(e,r,s){const i={parent:s,parser:this.#i,index:0};return this.isHighlighted(e,s)&&(e.highlighted=e.highlighted instanceof t?this.#i:i),this.resolve().toString(e,r,i)}}class p extends t{#r;get parser(){return this.#r}#n;get type(){return this.#n}static Type={NEGATIVE_AHEAD:"?!",NEGATIVE_BEHIND:"?<!",POSITIVE_AHEAD:"?=",POSITIVE_BEHIND:"?<="};constructor(e,t){super(),this.#r=e,this.#n=t}parse(t,r,s){let i=this.#r.parse(t,r,{parent:s,parser:this.#r,index:0});return i=i.status==(this.#n===p.Type.POSITIVE_AHEAD)?e.makeSuccess(r,"",s,r):e.makeFailure(),i}doToString(e,r,s){let i="("+this.#n+this.#r.toString(e,r,{parent:s,parser:this.#r,index:0})+")";return this.isHighlighted(e,s)&&(i=i.replace(/(\n)|$/,"\n"+t.indentation.repeat(r)+"^".repeat(this.#n.length+1)+" "+t.highlight+"$1")),i}}class o extends t{#r;get parser(){return this.#r}#a;get mapper(){return this.#a}constructor(e,t){super(),this.#r=e,this.#a=t}parse(e,t,r){const s=this.#r.parse(e,t,{parent:r,parser:this.#r,index:0});return s.status&&(s.value=this.#a(s.value)),s}doToString(e,r,s){let i=this.#a.toString();(i.length>60||i.includes("\n"))&&(i="(...) => { ... }");const n={parent:s,parser:this.#r,index:0};this.isHighlighted(e,s)&&(e.highlighted=e.highlighted instanceof t?this.#r:n);let a=this.#r.toString(e,r,n);return a=t.appendBeforeHighlight(a,` -> map<${i}>`),a}}class u extends t{#h;get regexp(){return this.#h}#p;#o;constructor(e,t){super(),e instanceof RegExp?(this.#h=e,this.#p=new RegExp(`^(?:${e.source})`,e.flags)):e instanceof u&&(this.#h=e.#h,this.#p=e.#p),this.#o=t}parse(t,r,s){const i=this.#p.exec(t.input.substring(r));i&&(r+=i[0].length);return i?e.makeSuccess(r,this.#o>=0?i[this.#o]:i,s,r):e.makeFailure()}doToString(e,r,s){let i="/"+this.#h.source+"/";return this.isHighlighted(e,s)&&(i+="\n"+t.indentation.repeat(r)+"^".repeat(i.length)+" "+t.highlight),i}}class l extends t{#t;get parsers(){return this.#t}constructor(...e){super(),this.#t=e}parse(t,r,s){const i=new Array(this.#t.length),n=e.makeSuccess(r,i);for(let e=0;e<this.#t.length;++e){const r=this.#t[e].parse(t,n.position,{parent:s,parser:this.#t[e],index:e});if(r.bestPosition>n.bestPosition&&(n.bestParser=r.bestParser,n.bestPosition=r.bestPosition),!r.status){n.status=!1,n.value=null;break}n.value[e]=r.value,n.position=r.position}return n}doToString(e,r,s){const i=t.indentation.repeat(r),n=t.indentation.repeat(r+1);return"SEQ<\n"+(this.isHighlighted(e,s)?`${i}^^^ ${t.highlight}\n`:"")+this.#t.map(((t,i)=>n+t.toString(e,r+1,{parent:s,parser:t,index:i}))).join("\n")+"\n"+i+">"}}class g extends t{#r;get parser(){return this.#r}#u;get min(){return this.#u}#l;get max(){return this.#l}constructor(e,t=0,r=Number.POSITIVE_INFINITY){if(super(),t>r)throw new Error("Min is greater than max");this.#r=e,this.#u=t,this.#l=r}parse(t,r,s){const i=e.makeSuccess(r,[],s);for(let e=0;e<this.#l;++e){const r=this.#r.parse(t,i.position,{parent:s,parser:this.#r,index:0});if(r.bestPosition>i.bestPosition&&(i.bestParser=r.bestParser,i.bestPosition=r.bestPosition),!r.status){e<this.#u&&(i.status=!1,i.value=null);break}i.value.push(r.value),i.position=r.position}return i}doToString(e,r,s){let i=this.parser.toString(e,r,{parent:s,parser:this.parser,index:0});const n=0===this.#u&&1===this.#l?"?":0===this.#u&&this.#l===Number.POSITIVE_INFINITY?"*":1===this.#u&&this.#l===Number.POSITIVE_INFINITY?"+":"{"+this.#u+(this.#u!==this.#l?","+this.#l:"")+"}";return this.isHighlighted(e,s)?i+=n+"\n"+" ".repeat(t.lastRowLength(i,t.indentation.length*r))+"^".repeat(n.length)+" "+t.highlight:i=t.appendBeforeHighlight(i,n),i}}class c{#r;Self;static lineColumnFromOffset(e,t){const r=e.substring(0,t).split("\n");return{line:r.length,column:r[r.length-1].length+1}}static#g=([e,t])=>e;static#c=([e,t])=>t;static#d=([e,t])=>[e,...t];static#m=e=>e instanceof Array?e.join(""):e;static#x=e=>String.raw`[^${e}\\]*(?:\\.[^${e}\\]*)*`;static#b=/[-\+]?(?:\d*\.)?\d+/;static number=this.reg(new RegExp(this.#b.source+String.raw`(?!\.)`)).map(Number);static numberInteger=this.reg(/[\-\+]?\d+(?!\.\d)/).map(Number);static numberBigInteger=this.reg(this.numberInteger.getParser().parser.regexp).map(BigInt);static numberNatural=this.reg(/\d+/).map(Number);static numberExponential=this.reg(new RegExp(this.#b.source+String.raw`(?:[eE][\+\-]?\d+)?(?!\.)`)).map(Number);static numberUnit=this.reg(/\+?(?:0(?:\.\d+)?|1(?:\.0+)?)(?![\.\d])/).map(Number);static numberByte=this.reg(/0*(?:25[0-5]|2[0-4]\d|1?\d?\d)(?!\d|\.)/).map(Number);static whitespace=this.reg(/\s+/);static whitespaceOpt=this.reg(/\s*/);static whitespaceInline=this.reg(/[^\S\n]+/);static whitespaceInlineOpt=this.reg(/[^\S\n]+/);static whitespaceMultiline=this.reg(/\s*?\n\s*/);static doubleQuotedString=this.regArray(new RegExp(`"(${this.#x('"')})"`)).map(this.#c);static singleQuotedString=this.regArray(new RegExp(`'(${this.#x("'")})'`)).map(this.#c);static backtickQuotedString=this.regArray(new RegExp(`\`(${this.#x("`")})\``)).map(this.#c);constructor(e,t=!1){this.#r=e}getParser(){return this.#r}run(t){const r=this.#r.parse(e.makeContext(this,t),0,e.makePathNode(this.#r));return r.position!==t.length&&(r.status=!1),r}parse(e){const t=this.run(e);if(!t.status){const r=60,s=[Math.ceil(r/2),Math.floor(r/2)],i=c.lineColumnFromOffset(e,t.bestPosition);let n=t.bestPosition;const a=e.replaceAll(/^(\s)+|\s{6,}|\s*?\n\s*/g,((e,r,s)=>{let i=r?"...":" ... ";return s<=t.bestPosition&&(t.bestPosition<s+e.length?n-=t.bestPosition-s:n-=e.length-i.length),i})),h=a.substring(0,r).trimEnd(),p=Math.min(e.substring(t.bestPosition-s[0]).match(/^\s*/)[0].length,s[0]-1);let o=Math.min(n,s[0]-p);s[0]=Math.max(0,n-s[0])+p,s[1]=Math.min(e.length,s[0]+r);let u=a.substring(...s);throw s[0]>0&&(u="..."+u,o+=3),s[1]<a.length-1&&(u+="..."),new Error(`Could not parse: ${h}\n\nInput: ${u}\n       `+" ".repeat(o)+`^ From here (line: ${i.line}, column: ${i.column}, offset: ${t.bestPosition})${t.bestPosition===e.length?", end of string":""}\n\nLast valid parser matched:`+this.toString(1,!0,t.bestParser)+"\n")}return t.value}static str(e){return new this(new r(e))}static reg(e,t=0){return new this(new u(e,t))}static regArray(e){return new this(new u(e,-1))}static success(){return new this(s.instance)}static failure(){return new this(a.instance)}static seq(...e){return new this(new l(...e.map((e=>e.getParser()))))}static alt(...e){return new this(new i(...e.map((e=>e.getParser()))))}static lookahead(e){return new this(new p(e.getParser(),p.Type.POSITIVE_AHEAD))}static lazy(e){return new this(new h(e))}times(e,t=e){return new c(new g(this.#r,e,t))}many(){return this.times(0,Number.POSITIVE_INFINITY)}atLeast(e){return this.times(e,Number.POSITIVE_INFINITY)}atMost(e){return this.times(0,e)}opt(){return c.alt(this,c.success())}sepBy(e,t=!1){return c.seq(this,c.seq(e,this).map(c.#c).many()).map(c.#d)}skipSpace(){return c.seq(this,c.whitespaceOpt).map(c.#g)}map(e){return new c(new o(this.#r,e))}chain(e){return new c(new n(this.#r,e))}assert(e){return this.chain(((t,r,s)=>e(t,r,s)?c.success().map((()=>t)):c.failure()))}join(e=""){return this.map(c.#m)}toString(r=0,s=!1,i=null){i instanceof c&&(i=i.getParser());const n=e.makeContext(this,"");return n.highlighted=i,(s?"\n"+t.indentation.repeat(r):"")+this.#r.toString(n,r,e.makePathNode(this.#r))}}export{c as default};
