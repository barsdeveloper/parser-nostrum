class t{static makeSuccess(t,e,r=null,s=0){return{status:!0,value:e,position:t,bestParser:r,bestPosition:s}}static makeFailure(t=0,e=null,r=0){return{status:!1,value:null,position:t,bestParser:e,bestPosition:r}}static makeContext(t=null,e=""){return{parsernostrum:t,input:e,highlighted:null}}static makePathNode(t,e=0,r=null){return{parent:r,current:t,index:e}}}class e{static indentation="    ";static highlight="Last valid parser";Self;static frame(t,e="",r=""){e=t?"[ "+e+" ]":"";let s=t.split("\n");const n=Math.max(...s.map((t=>t.length))),i=n<e.length?" ".repeat(e.length-n):"";for(let t=0;t<s.length;++t)s[t]=r+"| "+s[t]+" ".repeat(n-s[t].length)+i+" |";e.length<n&&(e+="─".repeat(n-e.length));const a="┌─"+e+"─┐",o=r+"└─"+"─".repeat(e.length)+"─┘";return s=[a,...s,o],s.join("\n")}makePath(t,e){return{current:this,parent:t,index:e}}isHighlighted(t,r){if(t.highlighted instanceof e)return t.highlighted===this;if(!t.highlighted||!r?.current)return!1;let s,n;for(s=r,n=t.highlighted;s.current&&n.current;s=s.parent,n=n.parent)if(s.current!==n.current||s.index!==n.index)return!1;return!s.current&&!n.current}isVisited(t){if(!t)return!1;for(t=t.parent;null!=t;t=t.parent)if(t.current===this)return!0;return!1}parse(t,e,r,s){return null}toString(r=t.makeContext(null,""),s="",n=null,i=0){if(n=this.makePath(n,i),this.isVisited(n))return"<...>";const a=this.isVisited(n),o=this.isHighlighted(r,n);let h=a?"<...>":this.doToString(r,o?"":s,n,i);return o&&(h=e.frame(h,e.highlight,s)),h}doToString(t,e,r,s){return`${this.constructor.name} does not implement toString()`}}class r extends e{#t;get value(){return this.#t}constructor(t){super(),this.#t=t}parse(e,r,s,n){s=this.makePath(s,n);const i=r+this.#t.length,a=e.input.substring(r,i);return this.#t===a?t.makeSuccess(i,this.#t,s,i):t.makeFailure()}doToString(t,e,r,s){return`"${this.value.replaceAll("\n","\\n").replaceAll('"','\\"')}"`}}class s extends e{static instance=new s;parse(e,r,s,n){return s=this.makePath(s,n),t.makeSuccess(r,"",s,0)}doToString(t,e,r,s){return"<SUCCESS>"}}class n extends e{#e;get parsers(){return this.#e}constructor(...t){super(),this.#e=t}parse(e,r,s,n){s=this.makePath(s,n);const i=t.makeSuccess(0,"");for(let t=0;t<this.#e.length;++t){const n=this.#e[t].parse(e,r,s,t);if(n.bestPosition>i.bestPosition&&(i.bestParser=n.bestParser,i.bestPosition=n.bestPosition),n.status)return i.value=n.value,i.position=n.position,i}return i.status=!1,i.value=null,i}doToString(t,n,i,a){if(2===this.#e.length&&this.#e[1]instanceof s){let e=this.#e[0].toString(t,n,i,0);return this.#e[0]instanceof r||(e="<"+e+">"),e+="?",e}const o=n+e.indentation;return"ALT<\n"+o+this.#e.map(((r,s)=>r.toString(t,o+" ".repeat(0===s?0:e.indentation.length-2),i,s))).join("\n"+o+"| ")+"\n"+n+">"}}class i extends e{#r;get parser(){return this.#r}#s;constructor(t,e){super(),this.#r=t,this.#s=e}parse(t,e,r,s){r=this.makePath(r,s);const n=this.#r.parse(t,e,r,0);if(!n.status)return n;const i=this.#s(n.value,t.input,n.position).getParser().parse(t,n.position);return n.bestPosition>i.bestPosition&&(i.bestParser=n.bestParser,i.bestPosition=n.bestPosition),i}doToString(t,e,r,s){return this.#r.toString(t,e,r,0)+" => chained<f()>"}}class a extends e{static instance=new a;parse(e,r,s,n){return t.makeFailure()}doToString(t,e,r,s){return"<FAILURE>"}}class o extends e{#r;get parser(){return this.#r}#n="";constructor(t,e){super(),this.#r=t,this.#n=e}makePath(t,e){return t}parse(t,e,r,s){return this.parse=this.#r.parse.bind(this.#r),this.parse(t,e,r,s)}doToString(t,r,s,n){let i=this.#r.toString(t,"",s,n);return i=e.frame(i,this.#n,r),i}}class h extends e{#r;#i;constructor(t){super(),this.#r=t}makePath(t,e){return t}isHighlighted(t,r){if(super.isHighlighted(t,r)){const s={parent:r,parser:this.#i,index:0};t.highlighted=t.highlighted instanceof e?this.#i:s}return!1}resolve(){return this.#i||(this.#i=this.#r().getParser()),this.#i}parse(t,e,r,s){return this.resolve(),this.parse=this.#i.parse.bind(this.#i),this.parse(t,e,r,s)}doToString(t,e,r,s){return this.resolve(),this.doToString=this.#i.toString.bind(this.#i),this.doToString(t,e,r,s)}}class u extends e{#r;get parser(){return this.#r}#a;get type(){return this.#a}static Type={NEGATIVE_AHEAD:"?!",NEGATIVE_BEHIND:"?<!",POSITIVE_AHEAD:"?=",POSITIVE_BEHIND:"?<="};constructor(t,e){super(),this.#r=t,this.#a=e}parse(e,r,s,n){s=this.makePath(s,n);let i=this.#r.parse(e,r,s,0);return i=i.status==(this.#a===u.Type.POSITIVE_AHEAD)?t.makeSuccess(r,"",s,r):t.makeFailure(),i}doToString(t,e,r,s){return"("+this.#a+this.#r.toString(t,e,r,0)+")"}}class p extends e{#o;get regexp(){return this.#o}#h;#u;static#p=t=>String.raw`[^${t}\\]*(?:\\.[^${t}\\]*)*`;static#c=/[-\+]?(?:\d*\.)?\d+/;static common={number:new RegExp(this.#c.source+String.raw`(?!\.)`),numberInteger:/[\-\+]?\d+(?!\.\d)/,numberNatural:/\d+/,numberExponential:new RegExp(this.#c.source+String.raw`(?:[eE][\+\-]?\d+)?(?!\.)`),numberUnit:/\+?(?:0(?:\.\d+)?|1(?:\.0+)?)(?![\.\d])/,numberByte:/0*(?:25[0-5]|2[0-4]\d|1?\d?\d)(?!\d|\.)/,whitespace:/\s+/,whitespaceOpt:/\s*/,whitespaceInline:/[^\S\n]+/,whitespaceInlineOpt:/[^\S\n]*/,whitespaceMultiline:/\s*?\n\s*/,doubleQuotedString:new RegExp(`"(${this.#p('"')})"`),singleQuotedString:new RegExp(`'(${this.#p("'")})'`),backtickQuotedString:new RegExp("`("+this.#p("`")+")`")};constructor(t,e){super(),this.#o=t,this.#h=new RegExp(`^(?:${t.source})`,t.flags),this.#u=e}parse(e,r,s,n){s=this.makePath(s,n);const i=this.#h.exec(e.input.substring(r));i&&(r+=i[0].length);return i?t.makeSuccess(r,this.#u(i),s,r):t.makeFailure()}doToString(t,e,r,s){let n="/"+this.#o.source+"/";const i=Object.entries(p.common).find((([t,e])=>e.source===this.#o.source))?.[0];return i&&(n="P."+i),n}}class c extends e{#r;get parser(){return this.#r}#l;get mapper(){return this.#l}constructor(t,e){super(),this.#r=t,this.#l=e}isHighlighted(t,r){if(super.isHighlighted(t,r)){const s={parent:r,parser:this.#r,index:0};t.highlighted=t.highlighted instanceof e?this.#r:s}return!1}parse(t,e,r,s){r=this.makePath(r,s);const n=this.#r.parse(t,e,r,0);return n.status&&(n.value=this.#l(n.value)),n}doToString(t,e,r,s){let n=this.#r.toString(t,e,r,0);if(this.#r instanceof p&&Object.values(p.common).includes(this.#r.regexp))return this.#r.regexp===p.common.numberInteger&&this.#l===BigInt?"P.numberBigInteger":n;let i=this.#l.toString();return(i.length>60||i.includes("\n"))&&(i="(...) => { ... }"),n+=` -> map<${i}>`,n}}class l extends p{static#l=t=>t;constructor(t){super(t,l.#l)}}class g extends p{constructor(t,e=0){super(t,(t=>t[e]))}}class m extends e{#e;get parsers(){return this.#e}constructor(...t){super(),this.#e=t}parse(e,r,s,n){s=this.makePath(s,n);const i=new Array(this.#e.length),a=t.makeSuccess(r,i);for(let t=0;t<this.#e.length;++t){const r=this.#e[t].parse(e,a.position,s,t);if(r.bestPosition>a.bestPosition&&(a.bestParser=r.bestParser,a.bestPosition=r.bestPosition),!r.status){a.status=!1,a.value=null;break}a.value[t]=r.value,a.position=r.position}return a}doToString(t,r,s,n){const i=r+e.indentation,a="SEQ<\n"+i+this.#e.map(((e,r)=>e.toString(t,i,s,r))).join("\n"+i)+"\n"+r+">";return a}}class d extends e{#r;get parser(){return this.#r}#g;get min(){return this.#g}#m;get max(){return this.#m}constructor(t,e=0,r=Number.POSITIVE_INFINITY){if(super(),e>r)throw new Error("Min is greater than max");this.#r=t,this.#g=e,this.#m=r}parse(e,r,s,n){s=this.makePath(s,n);const i=t.makeSuccess(r,[],s);for(let t=0;t<this.#m;++t){const r=this.#r.parse(e,i.position,s,0);if(r.bestPosition>i.bestPosition&&(i.bestParser=r.bestParser,i.bestPosition=r.bestPosition),!r.status){t<this.#g&&(i.status=!1,i.value=null);break}i.value.push(r.value),i.position=r.position}return i}doToString(t,e,r,s){let n=this.parser.toString(t,e,r,0);return n+=0===this.#g&&1===this.#m?"?":0===this.#g&&this.#m===Number.POSITIVE_INFINITY?"*":1===this.#g&&this.#m===Number.POSITIVE_INFINITY?"+":"{"+this.#g+(this.#g!==this.#m?","+this.#m:"")+"}",n}}class b{#r;Self;static lineColumnFromOffset(t,e){const r=t.substring(0,e).split("\n");return{line:r.length,column:r[r.length-1].length+1}}static#d=([t,e])=>t;static#b=([t,e])=>e;static#P=([t,e])=>[t,...e];static#S=t=>t instanceof Array?t.join(""):t;static#p=t=>String.raw`[^${t}\\]*(?:\\.[^${t}\\]*)*`;static number=this.reg(p.common.number).map(Number);static numberInteger=this.reg(p.common.numberInteger).map(Number);static numberBigInteger=this.reg(this.numberInteger.getParser().parser.regexp).map(BigInt);static numberNatural=this.reg(p.common.numberNatural).map(Number);static numberExponential=this.reg(p.common.numberExponential).map(Number);static numberUnit=this.reg(p.common.numberUnit).map(Number);static numberByte=this.reg(p.common.numberByte).map(Number);static whitespace=this.reg(p.common.whitespace);static whitespaceOpt=this.reg(p.common.whitespaceOpt);static whitespaceInline=this.reg(p.common.whitespaceInline);static whitespaceInlineOpt=this.reg(p.common.whitespaceInlineOpt);static whitespaceMultiline=this.reg(p.common.whitespaceMultiline);static doubleQuotedString=this.reg(p.common.doubleQuotedString,1);static singleQuotedString=this.reg(p.common.singleQuotedString,1);static backtickQuotedString=this.reg(p.common.backtickQuotedString,1);constructor(t,e=!1){this.#r=t}static#x(t){const e=[];for(;t;)e.push(t),t=t.parent;e.reverse();let r=new Map;for(let t=1;t<e.length;++t){const s=r.get(e[t].current);void 0!==s?(e[t+1]&&(e[t+1].parent=e[s]),r=new Map([...r.entries()].filter((([e,r])=>r<=s||r>t))),r.set(e[t].current,s),e.splice(s+1,t-s),t=s):r.set(e[t].current,t)}return e[e.length-1]}getParser(){return this.#r}run(e){const r=this.#r.parse(t.makeContext(this,e),0,t.makePathNode(),0);return r.position!==e.length&&(r.status=!1),r}parse(t){const r=this.run(t);if(r.status)return r.value;const s=[Math.ceil(30),Math.floor(30)],n=b.lineColumnFromOffset(t,r.bestPosition);let i=r.bestPosition;const a=t.replaceAll(/^(\s)+|\s{6,}|\s*?\n\s*/g,((t,e,s)=>{let n=e?"...":" ... ";return s<=r.bestPosition&&(r.bestPosition<s+t.length?i-=r.bestPosition-s:i-=t.length-n.length),n})),o=a.substring(0,60).trimEnd(),h=Math.min(t.substring(r.bestPosition-s[0]).match(/^\s*/)[0].length,s[0]-1);let u=Math.min(i,s[0]-h);s[0]=Math.max(0,i-s[0])+h,s[1]=Math.min(t.length,s[0]+60);let p=a.substring(...s);s[0]>0&&(p="..."+p,u+=3),s[1]<a.length-1&&(p+="...");const c=this.toString(e.indentation,!0,b.#x(r.bestParser));throw new Error(`Could not parse: ${o}\n\nInput: ${p}\n       `+" ".repeat(u)+`^ From here (line: ${n.line}, `+`column: ${n.column}, `+`offset: ${r.bestPosition})${r.bestPosition===t.length?", end of string":""}\n\n`+(r.bestParser?"Last valid parser matched:":"No parser matched:")+c+"\n")}static str(t){return new this(new r(t))}static reg(t,e=0){return new this(new g(t,e))}static regArray(t){return new this(new l(t))}static success(){return new this(s.instance)}static failure(){return new this(a.instance)}static seq(...t){return new this(new m(...t.map((t=>t.getParser()))))}static alt(...t){return new this(new n(...t.map((t=>t.getParser()))))}static lookahead(t){return new this(new u(t.getParser(),u.Type.POSITIVE_AHEAD))}static lazy(t){return new this(new h(t))}times(t,e=t){return new b(new d(this.#r,t,e))}many(){return this.times(0,Number.POSITIVE_INFINITY)}atLeast(t){return this.times(t,Number.POSITIVE_INFINITY)}atMost(t){return this.times(0,t)}opt(){return b.alt(this,b.success())}sepBy(t,e=!1){return b.seq(this,b.seq(t,this).map(b.#b).many()).map(b.#P)}skipSpace(){return b.seq(this,b.whitespaceOpt).map(b.#d)}map(t){return new b(new c(this.#r,t))}chain(t){return new b(new i(this.#r,t))}assert(t){return this.chain(((e,r,s)=>t(e,r,s)?b.success().map((()=>e)):b.failure()))}join(t=""){return this.map(b.#S)}label(t=""){return new b(new o(this.#r,t))}toString(e="",r=!1,s=null){s instanceof b&&(s=s.getParser());const n=t.makeContext(this,"");n.highlighted=s;const i=t.makePathNode();return(r?"\n"+e:"")+this.#r.toString(n,e,i)}}export{b as default};
