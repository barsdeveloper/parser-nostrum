class e{static makeSuccess(e,t,r=null,s=0){return{status:!0,value:t,position:e,bestParser:r,bestPosition:s}}static makeFailure(e=0,t=null,r=0){return{status:!1,value:null,position:e,bestParser:t,bestPosition:r}}static makeContext(e=null,t=""){return{parsernostrum:e,input:t,highlighted:null}}static makePathNode(e,t=0,r=null){return{parent:r,parser:e,index:t}}}class t{static indentation="    ";static highlight="Last valid parser";Self;static lastRowLength(e,t=0){const r=e.match(/(?:\n|(^))([^\n]*)$/),s=void 0!==r[1]?t:0;return r[2].length+s}static frame(e,t="",r=""){t=e?"[ "+t+" ]":"";let s=e.split("\n");const n=Math.max(...s.map((e=>e.length))),i=n<t.length?" ".repeat(t.length-n):"";for(let e=0;e<s.length;++e)s[e]=r+"| "+s[e]+" ".repeat(n-s[e].length)+i+" |";t.length<n&&(t+="─".repeat(n-t.length));const a="┌─"+t+"─┐",o=r+"└─"+"─".repeat(t.length)+"─┘";return s=[a,...s,o],s.join("\n")}getConcreteParser(){return this}makePath(e,t){return{parent:e,parser:this,index:t}}isHighlighted(e,r){if(e.highlighted instanceof t)return e.highlighted===this;if(!e.highlighted||!r?.parser)return!1;let s,n,i,a;e:for(s=r,i=e.highlighted;s.parser&&i.parser;n=s,s=s.parent,a=i,i=i.parent)if(s.parser!==i.parser||s.index!==i.index){if(!n?.parser||!a?.parser)return!1;let e,t;for(e=s,t=i;e?.parser||t?.parser;e=e?.parent,t=t?.parent){const r=e?.parser===n.parser,o=t?.parser===a.parser;if(r||o){r&&(n=e),o&&(a=t),s=n,i=a;continue e}}return!1}return!0}isVisited(e){if(!e)return!1;for(e=e.parent;null!=e;e=e.parent)if(e.parser===this)return!0;return!1}parse(e,t,r,s){return null}toString(r=e.makeContext(null,""),s="",n=null,i=0){n=this.makePath(n,i);const a=this.isHighlighted(r,n);let o=this.isVisited(n)?"<...>":this.doToString(r,a?"":s,n,i);return a&&(o=t.frame(o,t.highlight,s)),o}doToString(e,t,r,s){return`${this.constructor.name} does not implement toString()`}}class r extends t{#e;get value(){return this.#e}constructor(e){super(),this.#e=e}parse(t,r,s,n){s=this.makePath(s,n);const i=r+this.#e.length,a=t.input.substring(r,i);return this.#e===a?e.makeSuccess(i,this.#e,s,i):e.makeFailure()}doToString(e,t,r,s){return`"${this.value.replaceAll("\n","\\n").replaceAll('"','\\"')}"`}}class s extends t{static instance=new s;parse(t,r,s,n){return s=this.makePath(s,n),e.makeSuccess(r,"",s,0)}doToString(e,t,r,s){return"<SUCCESS>"}}class n extends t{#t;get parsers(){return this.#t}constructor(...e){super(),this.#t=e}parse(t,r,s,n){s=this.makePath(s,n);const i=e.makeSuccess(0,"");for(let e=0;e<this.#t.length;++e){const n=this.#t[e].parse(t,r,s,e);if(n.bestPosition>i.bestPosition&&(i.bestParser=n.bestParser,i.bestPosition=n.bestPosition),n.status)return i.value=n.value,i.position=n.position,i}return i.status=!1,i.value=null,i}doToString(e,n,i,a){if(2===this.#t.length&&this.#t[1]instanceof s){let t=this.#t[0].toString(e,n,i,0);return this.#t[0]instanceof r||(t="<"+t+">"),t+="?",t}const o=n+t.indentation;return"ALT<\n"+o+this.#t.map(((r,s)=>r.toString(e,o+" ".repeat(0===s?0:t.indentation.length-2),i,s))).join("\n"+o+"| ")+"\n"+n+">"}}class i extends t{#r;get parser(){return this.#r}#s;constructor(e,t){super(),this.#r=e,this.#s=t}parse(e,t,r,s){r=this.makePath(r,s);const n=this.#r.parse(e,t,r,0);if(!n.status)return n;const i=this.#s(n.value,e.input,n.position).getParser().parse(e,n.position);return n.bestPosition>i.bestPosition&&(i.bestParser=n.bestParser,i.bestPosition=n.bestPosition),i}doToString(e,t,r,s){return this.#r.toString(e,t,r,0)+" => chained<f()>"}}class a extends t{static instance=new a;parse(t,r,s,n){return e.makeFailure()}doToString(e,t,r,s){return"<FAILURE>"}}class o extends t{#r;get parser(){return this.#r}#n="";constructor(e,t){super(),this.#r=e,this.#n=t}getConcreteParser(){return this.#r.getConcreteParser()}makePath(e,t){return e}parse(e,t,r,s){return this.parse=this.#r.parse.bind(this.#r),this.parse(e,t,r,s)}doToString(e,r,s,n){let i=this.#r.toString(e,"",s,n);return i=t.frame(i,this.#n,r),i}}class h extends t{#r;#i;constructor(e){super(),this.#r=e}getConcreteParser(){return this.resolve().getConcreteParser()}makePath(e,t){return e}isHighlighted(e,r){if(super.isHighlighted(e,r)){const s={parent:r,parser:this.#i,index:0};e.highlighted=e.highlighted instanceof t?this.#i:s}return!1}resolve(){return this.#i||(this.#i=this.#r().getParser()),this.#i}parse(e,t,r,s){return this.resolve(),this.parse=this.#i.parse.bind(this.#i),this.parse(e,t,r,s)}doToString(e,t,r,s){return this.resolve(),this.doToString=this.#i.toString.bind(this.#i),this.doToString(e,t,r,s)}}class p extends t{#r;get parser(){return this.#r}#a;get type(){return this.#a}static Type={NEGATIVE_AHEAD:"?!",NEGATIVE_BEHIND:"?<!",POSITIVE_AHEAD:"?=",POSITIVE_BEHIND:"?<="};constructor(e,t){super(),this.#r=e,this.#a=t}parse(t,r,s,n){s=this.makePath(s,n);let i=this.#r.parse(t,r,s,0);return i=i.status==(this.#a===p.Type.POSITIVE_AHEAD)?e.makeSuccess(r,"",s,r):e.makeFailure(),i}doToString(e,t,r,s){return"("+this.#a+this.#r.toString(e,t,r,0)+")"}}class u extends t{#o;get regexp(){return this.#o}#h;#p;static#u=e=>String.raw`[^${e}\\]*(?:\\.[^${e}\\]*)*`;static#c=/[-\+]?(?:\d*\.)?\d+/;static common={number:new RegExp(this.#c.source+String.raw`(?!\.)`),numberInteger:/[\-\+]?\d+(?!\.\d)/,numberNatural:/\d+/,numberExponential:new RegExp(this.#c.source+String.raw`(?:[eE][\+\-]?\d+)?(?!\.)`),numberUnit:/\+?(?:0(?:\.\d+)?|1(?:\.0+)?)(?![\.\d])/,numberByte:/0*(?:25[0-5]|2[0-4]\d|1?\d?\d)(?!\d|\.)/,whitespace:/\s+/,whitespaceOpt:/\s*/,whitespaceInline:/[^\S\n]+/,whitespaceInlineOpt:/[^\S\n]*/,whitespaceMultiline:/\s*?\n\s*/,doubleQuotedString:new RegExp(`"(${this.#u('"')})"`),singleQuotedString:new RegExp(`'(${this.#u("'")})'`),backtickQuotedString:new RegExp("`("+this.#u("`")+")`")};constructor(e,t){super(),this.#o=e,this.#h=new RegExp(`^(?:${e.source})`,e.flags),this.#p=t}parse(t,r,s,n){s=this.makePath(s,n);const i=this.#h.exec(t.input.substring(r));i&&(r+=i[0].length);return i?e.makeSuccess(r,this.#p(i),s,r):e.makeFailure()}doToString(e,t,r,s){let n="/"+this.#o.source+"/";const i=Object.entries(u.common).find((([e,t])=>t.source===this.#o.source))?.[0];return i&&(n="P."+i),n}}class c extends t{#r;get parser(){return this.#r}#l;get mapper(){return this.#l}constructor(e,t){super(),this.#r=e,this.#l=t}isHighlighted(e,r){if(super.isHighlighted(e,r)){const s={parent:r,parser:this.#r,index:0};e.highlighted=e.highlighted instanceof t?this.#r:s}return!1}parse(e,t,r,s){r=this.makePath(r,s);const n=this.#r.parse(e,t,r,0);return n.status&&(n.value=this.#l(n.value)),n}doToString(e,t,r,s){r=this.makePath(r,s);let n=this.#r.toString(e,t,r,0);if(this.#r instanceof u&&Object.values(u.common).includes(this.#r.regexp))return this.#r.regexp===u.common.numberInteger&&this.#l===BigInt?"P.numberBigInteger":n;let i=this.#l.toString();return(i.length>60||i.includes("\n"))&&(i="(...) => { ... }"),n+=` -> map<${i}>`,n}}class l extends u{static#l=e=>e;constructor(e){super(e,l.#l)}}class g extends u{constructor(e,t=0){super(e,(e=>e[t]))}}class m extends t{#t;get parsers(){return this.#t}constructor(...e){super(),this.#t=e}parse(t,r,s,n){s=this.makePath(s,n);const i=new Array(this.#t.length),a=e.makeSuccess(r,i);for(let e=0;e<this.#t.length;++e){const r=this.#t[e].parse(t,a.position,s,e);if(r.bestPosition>a.bestPosition&&(a.bestParser=r.bestParser,a.bestPosition=r.bestPosition),!r.status){a.status=!1,a.value=null;break}a.value[e]=r.value,a.position=r.position}return a}doToString(e,r,s,n){const i=r+t.indentation,a="SEQ<\n"+i+this.#t.map(((t,r)=>t.toString(e,i,s,r))).join("\n"+i)+"\n"+r+">";return a}}class d extends t{#r;get parser(){return this.#r}#g;get min(){return this.#g}#m;get max(){return this.#m}constructor(e,t=0,r=Number.POSITIVE_INFINITY){if(super(),t>r)throw new Error("Min is greater than max");this.#r=e,this.#g=t,this.#m=r}parse(t,r,s,n){s=this.makePath(s,n);const i=e.makeSuccess(r,[],s);for(let e=0;e<this.#m;++e){const r=this.#r.parse(t,i.position,s,0);if(r.bestPosition>i.bestPosition&&(i.bestParser=r.bestParser,i.bestPosition=r.bestPosition),!r.status){e<this.#g&&(i.status=!1,i.value=null);break}i.value.push(r.value),i.position=r.position}return i}doToString(e,t,r,s){let n=this.parser.toString(e,t,r,0);return n+=0===this.#g&&1===this.#m?"?":0===this.#g&&this.#m===Number.POSITIVE_INFINITY?"*":1===this.#g&&this.#m===Number.POSITIVE_INFINITY?"+":"{"+this.#g+(this.#g!==this.#m?","+this.#m:"")+"}",n}}class b{#r;Self;static lineColumnFromOffset(e,t){const r=e.substring(0,t).split("\n");return{line:r.length,column:r[r.length-1].length+1}}static#d=([e,t])=>e;static#b=([e,t])=>t;static#P=([e,t])=>[e,...t];static#S=e=>e instanceof Array?e.join(""):e;static#u=e=>String.raw`[^${e}\\]*(?:\\.[^${e}\\]*)*`;static number=this.reg(u.common.number).map(Number);static numberInteger=this.reg(u.common.numberInteger).map(Number);static numberBigInteger=this.reg(this.numberInteger.getParser().parser.regexp).map(BigInt);static numberNatural=this.reg(u.common.numberNatural).map(Number);static numberExponential=this.reg(u.common.numberExponential).map(Number);static numberUnit=this.reg(u.common.numberUnit).map(Number);static numberByte=this.reg(u.common.numberByte).map(Number);static whitespace=this.reg(u.common.whitespace);static whitespaceOpt=this.reg(u.common.whitespaceOpt);static whitespaceInline=this.reg(u.common.whitespaceInline);static whitespaceInlineOpt=this.reg(u.common.whitespaceInlineOpt);static whitespaceMultiline=this.reg(u.common.whitespaceMultiline);static doubleQuotedString=this.reg(u.common.doubleQuotedString,1);static singleQuotedString=this.reg(u.common.singleQuotedString,1);static backtickQuotedString=this.reg(u.common.backtickQuotedString,1);constructor(e,t=!1){this.#r=e}getParser(){return this.#r}run(t){const r=this.#r.parse(e.makeContext(this,t),0,e.makePathNode(),0);return r.position!==t.length&&(r.status=!1),r}parse(e){const r=this.run(e);if(r.status)return r.value;const s=[Math.ceil(30),Math.floor(30)],n=b.lineColumnFromOffset(e,r.bestPosition);let i=r.bestPosition;const a=e.replaceAll(/^(\s)+|\s{6,}|\s*?\n\s*/g,((e,t,s)=>{let n=t?"...":" ... ";return s<=r.bestPosition&&(r.bestPosition<s+e.length?i-=r.bestPosition-s:i-=e.length-n.length),n})),o=a.substring(0,60).trimEnd(),h=Math.min(e.substring(r.bestPosition-s[0]).match(/^\s*/)[0].length,s[0]-1);let p=Math.min(i,s[0]-h);s[0]=Math.max(0,i-s[0])+h,s[1]=Math.min(e.length,s[0]+60);let u=a.substring(...s);s[0]>0&&(u="..."+u,p+=3),s[1]<a.length-1&&(u+="...");const c=this.toString(t.indentation,!0,r.bestParser);throw new Error(`Could not parse: ${o}\n\nInput: ${u}\n       `+" ".repeat(p)+`^ From here (line: ${n.line}, column: ${n.column}, offset: ${r.bestPosition})${r.bestPosition===e.length?", end of string":""}\n\n`+(r.bestParser?"Last valid parser matched:":"No parser matched:")+c+"\n")}static str(e){return new this(new r(e))}static reg(e,t=0){return new this(new g(e,t))}static regArray(e){return new this(new l(e))}static success(){return new this(s.instance)}static failure(){return new this(a.instance)}static seq(...e){return new this(new m(...e.map((e=>e.getParser()))))}static alt(...e){return new this(new n(...e.map((e=>e.getParser()))))}static lookahead(e){return new this(new p(e.getParser(),p.Type.POSITIVE_AHEAD))}static lazy(e){return new this(new h(e))}times(e,t=e){return new b(new d(this.#r,e,t))}many(){return this.times(0,Number.POSITIVE_INFINITY)}atLeast(e){return this.times(e,Number.POSITIVE_INFINITY)}atMost(e){return this.times(0,e)}opt(){return b.alt(this,b.success())}sepBy(e,t=!1){return b.seq(this,b.seq(e,this).map(b.#b).many()).map(b.#P)}skipSpace(){return b.seq(this,b.whitespaceOpt).map(b.#d)}map(e){return new b(new c(this.#r,e))}chain(e){return new b(new i(this.#r,e))}assert(e){return this.chain(((t,r,s)=>e(t,r,s)?b.success().map((()=>t)):b.failure()))}join(e=""){return this.map(b.#S)}label(e=""){return new b(new o(this.#r,e))}toString(t="",r=!1,s=null){s instanceof b&&(s=s.getParser().getConcreteParser());const n=e.makeContext(this,"");n.highlighted=s;const i=e.makePathNode();return(r?"\n"+t:"")+this.#r.toString(n,t,i)}}export{b as default};
