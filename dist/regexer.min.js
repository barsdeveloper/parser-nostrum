class e{#e=new Map;get(e,t){return this.#e.get(e)?.get(t)}set(e,t,r){let s=this.#e.get(e);return s||(s=new Map,this.#e.set(e,s)),s.set(t,r),this}setGet(e,t,r){return this.set(e,t,r),r}}class t{static makeSuccess(e,t){return{status:!0,value:t,position:e}}static makeFailure(e){return{status:!1,value:null,position:e}}static makeContext(t=null,r=""){return{regexer:t,input:r,equals:new e,visited:new Map}}}class r{static isTerminal=!1;static indentation="    ";#t;predicate=e=>this===e||e instanceof Function&&this instanceof e;isActualParser=!0;Self;static mergeResults(e,t){return t?{status:e.status,position:e.position,value:e.value}:e}constructor(){this.Self=this.constructor}unwrap(e=null){return[]}wrap(...e){return null}parse(e,t){return null}actualParser(e=[],t=[],r=null){let s=(!this.isActualParser||e.some(this.predicate))&&!t.some(this.predicate),a=s?this.unwrap(r):void 0;return s&&=1===a?.length,s?a[0].actualParser(e,t,r):this}withActualParser(e,t=[],r=[],s=null){let a=(!this.isActualParser||t.some(this.predicate))&&!r.some(this.predicate),n=a?this.unwrap(s):void 0;return a&&=1===n?.length,a?this.wrap(n[0].withActualParser(e,t,r,s)):e}equals(e,t,r){let s=this;if(s===t)return!0;if(r||(s=this.actualParser(),t=t.actualParser()),t instanceof s.constructor&&!(s instanceof t.constructor)||t.resolve&&!s.resolve){const e=s;s=t,t=e}let a=e.equals.get(s,t);return void 0!==a||void 0===a&&(e.equals.set(s,t,!0),a=s.doEquals(e,t,r),e.equals.set(s,t,a)),a}doEquals(e,t,r){return!1}toString(e=t.makeContext(null,""),r=0){return e.visited.has(this)?"<...>":(e.visited.set(this,null),this.doToString(e,r))}doToString(e,t=0){return`${this.constructor.name} does not implement toString()`}}class s extends r{static isTerminal=!0;static successParserInstance;#r;get value(){return this.#r}constructor(e){super(),this.#r=e}parse(e,r){const s=r+this.#r.length,a=e.input.substring(r,s);return this.#r===a?t.makeSuccess(s,this.#r):t.makeFailure(r)}doEquals(e,t,r){return t instanceof s&&this.#r===t.#r}doToString(e,t=0){const r=this.value.replaceAll("\n","\\n");return 1!==this.value.length||this.value.trim()!==this.value?`"${r.replaceAll('"','\\"')}"`:r}}class a extends s{static instance=new a;static{s.successParserInstance=this.instance}constructor(){super("")}doEquals(e,t,r){return r?t instanceof a:super.doEquals(e,t,!1)}doToString(e,t=0){return"<SUCCESS>"}}class n extends r{#s=!1;get backtracking(){return this.#s}#a;get parsers(){return this.#a}constructor(...e){super(),this.#a=e,1===this.#a.length&&(this.isActualParser=!1)}unwrap(){return[...this.#a]}wrap(...e){const t=new this.Self(...e);return t.#s=this.#s,t}asBacktracking(){const e=this.wrap(...this.#a);return e.#s=!0,e}parse(e,r){let s;for(let t=0;t<this.#a.length;++t)if(s=this.#a[t].parse(e,r),s.status)return s;return t.makeFailure(r)}doEquals(e,t,r){if(!(t instanceof n)||this.#a.length!=t.#a.length||this.#s!==t.#s)return!1;for(let s=0;s<this.#a.length;++s)if(!this.#a[s].equals(e,t.#a[s],r))return!1;return!0}doToString(e,t=0){const n=r.indentation.repeat(t),i=r.indentation.repeat(t+1);if(2===this.#a.length&&this.#a[1]instanceof a){let r=this.#a[0].toString(e,t);return this.#a[0]instanceof s||e.visited.has(this.#a[0])||(r="<"+r+">"),r+="?",r}return"ALT<\n"+i+this.#a.map((r=>r.toString(e,t+1))).join("\n"+i+"| ")+"\n"+n+">"}}class i extends r{#n;get parser(){return this.#n}#i;constructor(e,t){super(),this.#n=e,this.#i=t}unwrap(e=null){return[this.#n]}wrap(...e){return new i(e[0],this.#i)}parse(e,r){let s=this.#n.parse(e,r);return s.status?(s=this.#i(s.value,e.input,s.position)?.getParser().parse(e,s.position)??t.makeFailure(s.position),s):s}doEquals(e,t,r){return t instanceof i&&this.#i===t.#i&&this.#n.equals(e,t.parser,r)}doToString(e,t=0){return this.#n.toString(e,t)+" => chained<f()>"}}class u extends r{static isTerminal=!0;static instance=new u;parse(e,r){return t.makeFailure(r)}doEquals(e,t,r){return t instanceof u}doToString(e,t=0){return"<FAILURE>"}}class p extends r{#n;isActualParser=!1;#u;constructor(e){super(),this.#n=e}resolve(){return this.#u||(this.#u=this.#n().getParser()),this.#u}unwrap(e=null){return[this.resolve()]}wrap(...e){const t=this.#n().constructor;return new p((()=>new t(e[0])))}parse(e,t){return this.resolve(),this.#u.parse(e,t)}doEquals(e,t,r){if(t instanceof p){if(this.#n===t.#n)return!0;t=t.resolve()}else if(r)return!1;return this.resolve(),this.#u.equals(e,t,r)}doToString(e,t=0){return this.resolve().toString(e,t)}}class h extends r{#n;get parser(){return this.#n}#p;get type(){return this.#p}static Type={NEGATIVE_AHEAD:"?!",NEGATIVE_BEHIND:"?<!",POSITIVE_AHEAD:"?=",POSITIVE_BEHIND:"?<="};constructor(e,t){super(),this.#n=e,this.#p=t}unwrap(e=null){return[this.#n]}wrap(...e){return new h(e[0],this.#p)}parse(e,r){if(this.#p===h.Type.NEGATIVE_BEHIND||this.#p===h.Type.POSITIVE_BEHIND)throw new Error("Lookbehind is not implemented yet");return this.#n.parse(e,r).status==(this.#p===h.Type.POSITIVE_AHEAD)?t.makeSuccess(r,""):t.makeFailure(r)}doEquals(e,t,r){return this===t||t instanceof h&&this.#p===t.#p&&this.#n.equals(e,t.#n,r)}doToString(e,t=0){return"("+this.#p+this.#n.toString(e,t)+")"}}class c extends r{#n;get parser(){return this.#n}#h;get mapper(){return this.#h}isActualParser=!1;constructor(e,t){super(),this.#n=e,this.#h=t}unwrap(e=null){return[this.#n]}wrap(...e){return new c(e[0],this.#h)}parse(e,t){const r=this.#n.parse(e,t);return r.status&&(r.value=this.#h(r.value)),r}doEquals(e,t,r){return t instanceof c&&this.#h===t.#h&&this.#n.equals(e,t.#n,r)}doToString(e,t=0){let r=this.#h.toString();return(r.length>80||r.includes("\n"))&&(r="( ... ) => { ... }"),this.#n.toString(e,t)+` -> map<${r}>`}}class o extends r{static isTerminal=!0;#c;get regexp(){return this.#c}#o;#l;constructor(e,t){super(),e instanceof RegExp?(this.#c=e,this.#o=new RegExp(`^(?:${e.source})`,e.flags)):e instanceof o&&(this.#c=e.#c,this.#o=e.#o),this.#l=t}parse(e,r){const s=this.#o.exec(e.input.substring(r));return s?t.makeSuccess(r+s[0].length,this.#l>=0?s[this.#l]:s):t.makeFailure(r)}doEquals(e,t,r){return t instanceof o&&(!r||this.#l===t.#l)&&this.#c.source===t.#c.source}doToString(e,t=0){return"/"+this.#c.source+"/"}}class l extends r{#a;get parsers(){return this.#a}constructor(...e){super(),this.#a=e,1===this.#a.length&&(this.isActualParser=!1)}unwrap(e=null){return[...this.#a]}wrap(...e){return new l(...e)}parse(e,r){const s=new Array(this.#a.length),a=t.makeSuccess(r,s);for(let t=0;t<this.#a.length;++t){const r=this.#a[t].parse(e,a.position);if(!r.status)return r;a.value[t]=r.value,a.position=r.position}return a}doEquals(e,t,r){if(!(t instanceof l)||this.#a.length!=t.#a.length)return!1;for(let s=0;s<this.#a.length;++s)if(!this.#a[s].equals(e,t.#a[s],r))return!1;return!0}doToString(e,t=0){const s=r.indentation.repeat(t),a=r.indentation.repeat(t+1);return"SEQ<\n"+this.#a.map((r=>a+r.toString(e,t+1))).join("\n")+"\n"+s+">"}}class g extends r{#s=!1;get backtracking(){return this.#s}#n;get parser(){return this.#n}#g;get min(){return this.#g}#m;get max(){return this.#m}constructor(e,t=0,r=Number.POSITIVE_INFINITY){if(super(),t>r)throw new Error("Min is greater than max");this.#n=e,this.#g=t,this.#m=r}unwrap(e=null){return[this.#n]}wrap(...e){const t=new g(e[0],this.#g,this.#m);return this.#s&&(t.#s=!0),t}asBacktracking(){const e=new g(this.#n,this.#g,this.#m);return e.#s=!0,e}parse(e,r){const s=t.makeSuccess(r,[]);for(let t=0;t<this.#m;++t){const r=this.#n.parse(e,s.position);if(!r.status)return t>=this.#g?s:r;s.value.push(r.value),s.position=r.position}return s}doEquals(e,t,r){return t instanceof g&&this.#s===t.#s&&this.#g===t.#g&&this.#m===t.#m&&this.#n.equals(e,t.#n,r)}doToString(e,t=0){return this.parser.toString(e,t)+(0===this.#g&&1===this.#m?"?":0===this.#g&&this.#m===Number.POSITIVE_INFINITY?"*":1===this.#g&&this.#m===Number.POSITIVE_INFINITY?"+":"{"+this.#g+(this.#g!==this.#m?",":this.#m!==Number.POSITIVE_INFINITY?this.#m:"")+"}")}}class m extends n{constructor(e){super(e,a.instance)}unwrap(e=null){return[this.parsers[0]]}wrap(...e){return super.wrap(...e,a.instance)}}class d{#n;#d;#w=new Map;Self;static#x=e=>Number(e);static#f=([e,t])=>e;static#S=([e,t])=>t;static#E=([e,t])=>[e,...t];static#k=e=>e instanceof Array?e.join(""):e;static#I=e=>String.raw`[^${e}\\]*(?:\\.[^${e}\\]*)*`;static#v=/[-\+]?(?:\d*\.)?\d+/;static number=this.regexp(new RegExp(this.#v.source+String.raw`(?!\.)`)).map(this.#x);static numberNatural=this.regexp(/\d+/).map(this.#x);static numberExponential=this.regexp(new RegExp(this.#v.source+String.raw`(?:[eE][\+\-]?\d+)?(?!\.)`)).map(this.#x);static numberUnit=this.regexp(/\+?(?:0(?:\.\d+)?|1(?:\.0+)?)(?![\.\d])/).map(this.#x);static whitespace=this.regexp(/\s+/);static whitespaceInline=this.regexp(/[^\S\n]+/);static whitespaceMultiline=this.regexp(/\s*?\n\s*/);static optWhitespace=this.regexp(/\s*/);static doubleQuotedString=this.regexpGroups(new RegExp(`"(${this.#I('"')})"`)).map(this.#S);static singleQuotedString=this.regexpGroups(new RegExp(`'(${this.#I("'")})'`)).map(this.#S);static backtickQuotedString=this.regexpGroups(new RegExp(`\`(${this.#I("`")})\``)).map(this.#S);constructor(e,t=!1){this.Self=this.constructor,this.#n=e,this.#d=t}static optimize(e){}static equals(e,r,s=!1){const a=e instanceof d?e.getParser():e,n=r instanceof d?r.getParser():r;return a.equals(t.makeContext(e instanceof d?e:r instanceof d?r:null),n,s)}getParser(){return this.#n}run(e){const r=this.#n.parse(t.makeContext(this,e),0);return r.status&&r.position===e.length?r:t.makeFailure(r.position)}parse(e){const t=this.run(e);if(!t.status)throw new Error("Parsing error");return t.value}static str(e){return new this(new s(e))}static regexp(e,t=0){return new this(new o(e,t))}static regexpGroups(e){return new this(new o(e,-1))}static success(){return new this(a.instance)}static failure(){return new this(u.instance)}static seq(...e){return new this(new l(...e.map((e=>e.getParser()))))}static alt(...e){return new this(new n(...e.map((e=>e.getParser()))))}static lookahead(e){return new this(new h(e.getParser(),h.Type.POSITIVE_AHEAD))}static lazy(e){return new this(new p(e))}times(e,t=e){return new this.Self(new g(this.#n,e,t))}many(){return this.times(0,Number.POSITIVE_INFINITY)}atLeast(e){return this.times(e,Number.POSITIVE_INFINITY)}atMost(e){return this.times(0,e)}opt(){return new this.Self(new m(this.#n))}sepBy(e,t=!1){return this.Self.seq(this,this.Self.seq(e,this).map(d.#S).many()).map(d.#E)}skipSpace(){return this.Self.seq(this,this.Self.optWhitespace).map(d.#f)}map(e){return new this.Self(new c(this.#n,e))}chain(e){return new this.Self(new i(this.#n,e))}assert(e){return this.chain(((t,r,s)=>e(t,r,s)?this.Self.success().map((()=>t)):this.Self.failure()))}join(e=""){return this.map(d.#k)}toString(e=0,s=!1){return(s?"\n"+r.indentation.repeat(e):"")+this.#n.toString(t.makeContext(this,""),e)}}export{d as default};
