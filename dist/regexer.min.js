class e{static makeSuccess(e,t){return{status:!0,value:t,position:e}}static makeFailure(e){return{status:!1,value:null,position:e}}static makeContext(e=null,t=""){return{regexer:e,input:t,visited:new Map}}}class t{static indentation="    ";predicate=e=>this===e||e instanceof Function&&this instanceof e;isActualParser=!0;Self;static mergeResults(e,t){return t?{status:e.status,position:e.position,value:e.value}:e}constructor(){this.Self=this.constructor}unwrap(e=null){return[]}wrap(...e){return null}parse(e,t){return null}actualParser(e=[],t=[]){let r=(!this.isActualParser||e.some(this.predicate))&&!t.some(this.predicate),s=r?this.unwrap():void 0;return r&&=1===s?.length,r?s[0].actualParser(e,t):this}withActualParser(e,t=[],r=[]){let s=(!this.isActualParser||t.some(this.predicate))&&!r.some(this.predicate),i=s?this.unwrap():void 0;return s&&=1===i?.length,s?this.wrap(i[0].withActualParser(e,t,r)):e}toString(t=e.makeContext(null,""),r=0){return t.visited.has(this)?"<...>":(t.visited.set(this,null),this.doToString(t,r))}doToString(e,t=0){return`${this.constructor.name} does not implement toString()`}}class r extends t{static successParserInstance;#e;get value(){return this.#e}constructor(e){super(),this.#e=e}parse(t,r){const s=r+this.#e.length,i=t.input.substring(r,s);return this.#e===i?e.makeSuccess(s,this.#e):e.makeFailure(r)}doToString(e,t=0){const r=this.value.replaceAll("\n","\\n");return 1!==this.value.length||this.value.trim()!==this.value?`"${r.replaceAll('"','\\"')}"`:r}}class s extends r{static instance=new s;static{r.successParserInstance=this.instance}constructor(){super("")}doToString(e,t=0){return"<SUCCESS>"}}class i extends t{#t;get parsers(){return this.#t}constructor(...e){super(),this.#t=e,1===this.#t.length&&(this.isActualParser=!1)}unwrap(){return[...this.#t]}wrap(...e){return new this.Self(...e)}parse(t,r){let s;for(let e=0;e<this.#t.length;++e)if(s=this.#t[e].parse(t,r),s.status)return s;return e.makeFailure(r)}doToString(e,i=0){const n=t.indentation.repeat(i),a=t.indentation.repeat(i+1);if(2===this.#t.length&&this.#t[1]instanceof s){let t=this.#t[0].toString(e,i);return this.#t[0]instanceof r||e.visited.has(this.#t[0])||(t="<"+t+">"),t+="?",t}return"ALT<\n"+a+this.#t.map((t=>t.toString(e,i+1))).join("\n"+a+"| ")+"\n"+n+">"}}class n extends t{#r;get parser(){return this.#r}#s;constructor(e,t){super(),this.#r=e,this.#s=t}unwrap(e=null){return[this.#r]}wrap(...e){return new n(e[0],this.#s)}parse(t,r){let s=this.#r.parse(t,r);return s.status?(s=this.#s(s.value,t.input,s.position)?.getParser().parse(t,s.position)??e.makeFailure(s.position),s):s}doToString(e,t=0){return this.#r.toString(e,t)+" => chained<f()>"}}class a extends t{static instance=new a;parse(t,r){return e.makeFailure(r)}doToString(e,t=0){return"<FAILURE>"}}class p extends t{#r;isActualParser=!1;#i;constructor(e){super(),this.#r=e}resolve(){return this.#i||(this.#i=this.#r().getParser()),this.#i}unwrap(e=null){return[this.resolve()]}wrap(...e){const t=this.#r().constructor;return new p((()=>new t(e[0])))}parse(e,t){return this.resolve(),this.#i.parse(e,t)}doToString(e,t=0){return this.resolve().toString(e,t)}}class u extends t{#r;get parser(){return this.#r}#n;get type(){return this.#n}static Type={NEGATIVE_AHEAD:"?!",NEGATIVE_BEHIND:"?<!",POSITIVE_AHEAD:"?=",POSITIVE_BEHIND:"?<="};constructor(e,t){super(),this.#r=e,this.#n=t}unwrap(e=null){return[this.#r]}wrap(...e){return new u(e[0],this.#n)}parse(t,r){if(this.#n===u.Type.NEGATIVE_BEHIND||this.#n===u.Type.POSITIVE_BEHIND)throw new Error("Lookbehind is not implemented yet");return this.#r.parse(t,r).status==(this.#n===u.Type.POSITIVE_AHEAD)?e.makeSuccess(r,""):e.makeFailure(r)}doToString(e,t=0){return"("+this.#n+this.#r.toString(e,t)+")"}}class h extends t{#r;get parser(){return this.#r}#a;get mapper(){return this.#a}isActualParser=!1;constructor(e,t){super(),this.#r=e,this.#a=t}unwrap(e=null){return[this.#r]}wrap(...e){return new h(e[0],this.#a)}parse(e,t){const r=this.#r.parse(e,t);return r.status&&(r.value=this.#a(r.value)),r}doToString(e,t=0){let r=this.#a.toString();return(r.length>60||r.includes("\n"))&&(r="(...) => { ... }"),this.#r.toString(e,t)+` -> map<${r}>`}}class o extends i{constructor(e){super(e,s.instance)}unwrap(e=null){return[this.parsers[0]]}wrap(...e){return super.wrap(...e,s.instance)}}class c extends t{#p;get regexp(){return this.#p}#u;#h;constructor(e,t){super(),e instanceof RegExp?(this.#p=e,this.#u=new RegExp(`^(?:${e.source})`,e.flags)):e instanceof c&&(this.#p=e.#p,this.#u=e.#u),this.#h=t}parse(t,r){const s=this.#u.exec(t.input.substring(r));return s?e.makeSuccess(r+s[0].length,this.#h>=0?s[this.#h]:s):e.makeFailure(r)}doToString(e,t=0){return"/"+this.#p.source+"/"}}class l extends t{#t;get parsers(){return this.#t}constructor(...e){super(),this.#t=e,1===this.#t.length&&(this.isActualParser=!1)}unwrap(e=null){return[...this.#t]}wrap(...e){return new l(...e)}parse(t,r){const s=new Array(this.#t.length),i=e.makeSuccess(r,s);for(let e=0;e<this.#t.length;++e){const r=this.#t[e].parse(t,i.position);if(!r.status)return r;i.value[e]=r.value,i.position=r.position}return i}doToString(e,r=0){const s=t.indentation.repeat(r),i=t.indentation.repeat(r+1);return"SEQ<\n"+this.#t.map((t=>i+t.toString(e,r+1))).join("\n")+"\n"+s+">"}}class g extends t{#r;get parser(){return this.#r}#o;get min(){return this.#o}#c;get max(){return this.#c}constructor(e,t=0,r=Number.POSITIVE_INFINITY){if(super(),t>r)throw new Error("Min is greater than max");this.#r=e,this.#o=t,this.#c=r}unwrap(e=null){return[this.#r]}wrap(...e){return new g(e[0],this.#o,this.#c)}parse(t,r){const s=e.makeSuccess(r,[]);for(let e=0;e<this.#c;++e){const r=this.#r.parse(t,s.position);if(!r.status)return e>=this.#o?s:r;s.value.push(r.value),s.position=r.position}return s}doToString(e,t=0){return this.parser.toString(e,t)+(0===this.#o&&1===this.#c?"?":0===this.#o&&this.#c===Number.POSITIVE_INFINITY?"*":1===this.#o&&this.#c===Number.POSITIVE_INFINITY?"+":"{"+this.#o+(this.#o!==this.#c?","+this.#c:"")+"}")}}class m{#r;Self;static#l=e=>Number(e);static#g=([e,t])=>e;static#m=([e,t])=>t;static#w=([e,t])=>[e,...t];static#d=e=>e instanceof Array?e.join(""):e;static#S=e=>String.raw`[^${e}\\]*(?:\\.[^${e}\\]*)*`;static#x=/[-\+]?(?:\d*\.)?\d+/;static number=this.regexp(new RegExp(this.#x.source+String.raw`(?!\.)`)).map(this.#l);static numberNatural=this.regexp(/\d+/).map(this.#l);static numberExponential=this.regexp(new RegExp(this.#x.source+String.raw`(?:[eE][\+\-]?\d+)?(?!\.)`)).map(this.#l);static numberUnit=this.regexp(/\+?(?:0(?:\.\d+)?|1(?:\.0+)?)(?![\.\d])/).map(this.#l);static whitespace=this.regexp(/\s+/);static whitespaceInline=this.regexp(/[^\S\n]+/);static whitespaceMultiline=this.regexp(/\s*?\n\s*/);static optWhitespace=this.regexp(/\s*/);static doubleQuotedString=this.regexpGroups(new RegExp(`"(${this.#S('"')})"`)).map(this.#m);static singleQuotedString=this.regexpGroups(new RegExp(`'(${this.#S("'")})'`)).map(this.#m);static backtickQuotedString=this.regexpGroups(new RegExp(`\`(${this.#S("`")})\``)).map(this.#m);constructor(e,t=!1){this.Self=this.constructor,this.#r=e}getParser(){return this.#r}run(t){const r=this.#r.parse(e.makeContext(this,t),0);return r.status&&r.position===t.length?r:e.makeFailure(r.position)}parse(e){const t=this.run(e);if(!t.status)throw new Error("Parsing error");return t.value}static str(e){return new this(new r(e))}static regexp(e,t=0){return new this(new c(e,t))}static regexpGroups(e){return new this(new c(e,-1))}static success(){return new this(s.instance)}static failure(){return new this(a.instance)}static seq(...e){return new this(new l(...e.map((e=>e.getParser()))))}static alt(...e){return new this(new i(...e.map((e=>e.getParser()))))}static lookahead(e){return new this(new u(e.getParser(),u.Type.POSITIVE_AHEAD))}static lazy(e){return new this(new p(e))}times(e,t=e){return new this.Self(new g(this.#r,e,t))}many(){return this.times(0,Number.POSITIVE_INFINITY)}atLeast(e){return this.times(e,Number.POSITIVE_INFINITY)}atMost(e){return this.times(0,e)}opt(){return new this.Self(new o(this.#r))}sepBy(e,t=!1){return this.Self.seq(this,this.Self.seq(e,this).map(m.#m).many()).map(m.#w)}skipSpace(){return this.Self.seq(this,this.Self.optWhitespace).map(m.#g)}map(e){return new this.Self(new h(this.#r,e))}chain(e){return new this.Self(new n(this.#r,e))}assert(e){return this.chain(((t,r,s)=>e(t,r,s)?this.Self.success().map((()=>t)):this.Self.failure()))}join(e=""){return this.map(m.#d)}toString(r=0,s=!1){return(s?"\n"+t.indentation.repeat(r):"")+this.#r.toString(e.makeContext(this,""),r)}}export{m as default};
